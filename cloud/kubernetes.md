## 쿠버네티스를 사용하는 이유

1. 속도

   \- 시간당 제공할 수 있는 기능의 수가 아닌, 높은 가용성을 확보한 상태에서 서비스를 유지하며 제공할 수 있는 항목의 수를 의미

   \- 가용성을 확보할 수 있게 하는 핵심 개념 

   1) 불변성
       기존 인프라는 증분 업데이트로 시스템을 변경할 수 있는 인프라였지만, 불변형 인프라에서는 아티팩트가 발생하더라도 운영자의 수정을 통해 변경하는 것이 아니라 새로운 이미지가 생성되어 교체됨
       기존 컨테이너 이미지를 수정하는 것이 아니라 새로운 컨테이너 이미지를 만들고 컨테이너 레지스트리에 주입
       *아티팩트 생성과 생성 시 방법에 대한 기록 -> 새로운 버전에 오류가 있는 경우 오류를 명확하게 확인 가능
   2) 선언형 설정
       선언형 설정 <-> 명령형 설정
       명령형 설정 : 명령문 위주의 동작을 정의(예: A 실행, B 실행, C 실행)
       선언형 설정 : 요구하는 상태를 정의(실제 상태를 기술. 설정의 영향을 실행 이전에 해석하므로 오류 발생 가능성이 적음)
       변경에 대한 롤백을 쉽게 만들 수 있음(선언형 설정) <-> 되돌아오는 방법을 기술하지 않으므로 사실상 롤백 불가(명령형 설정)
       소스 제어, 코드 리뷰, 유닛 테스트를 선언형 설정에 사용 가능
   3) 자가 치유 시스템
       요구하는 상태 설정을 받으면 현재 상태를 요구하는 상태로 일치시키려고 
       끊임없이 확인하고 요구된 상태로 유지함

   => 결론적으로, <u>여기서 말하는 속도</u>는 단순 서비스 배포 시간의 단축을 의미하는 것이 아니라, <u>변경에 대한 롤백 쉽게 만들며</u> 

   <u>요구하는 상태 설정</u>과 일치시키려고 끊임없이 확인하고 <u>유지</u>하도록 설정되어 <u>높은 가용성을 확보한다는 의미</u>

<br/>


2. 확장성

   \- 분리

   분리된 아키텍처를 지향해 확장성 확보
   API와 로드밸런서는 시스템 각 부분들(컴포넌트)를 격리, 분리하는 역할을 함
   분리된 아키텍처에서 컴포넌트를 분리하면 프로그램 크기와 처리 용량을 증가시켜도 재설정이 필요 없음
   API를 통해 서버를 분리하면 개발에 집중할 수 있음

   \- 쉬운 애플리케이션 및 클러스터 확장

   불변적인 선언적 속성으로 서비스를 쉽게 확장 또는 자동 확장 설정 가능

   \- 클러스터 확장
   클러스터 내부 머신들은 서로 완전히 동일하고 컨테이너는 애플리케이션을 머신 세부사항과 분리하므로 
   새로운 자원을 클러스터에 추가하는 작업은 새로운 머신을 이미징하고 클러스터에 추가하기만 하면 됨

   \- 프로비저닝(provisioning): 사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요 시 
   시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것

   \- 애플리케이션 컨테이너 이미지와 머신을 분리하면 동일한 머신에서 각 마이크로서비스를 
   서로 간섭하지 않도록 배치할 수 있고 마이크로서비스 아키텍처에서 오버헤드와 비용을 줄일 수 있음?

   \- 쿠버네티스의 상태 진단과 롤아웃 기능은 애플리케이션 롤아웃과 안정성에 일관된 접근을 보장함?
   -> 개발 팀이 서비스 제품 생명주기와 운영에 영향을 미치지 않음

   \- 컨테이너 애플리케이션의 운영자의 책임과 클러스터 오케스트레이션 운영자 책임 분리
   -> 컨테이너 오케스트레이션 API의 안정성을 담당하는 엔지니어는 API를 이용해 동작하는 
   애플리케이션에 대해 고민할 필요 없이 오케스트레이션 SLA를 제공하는 일에만 전념하면 됨?

<br/>


3. 인프라 추상화

   \* 추상화 : 복잡한 자료, 모듈, 시스템에서 핵심적인 개념 또는 기능만 간추려서 노출시키는 것(예: 스마트폰 WIFI 기능, 자바 클래스 추상화)

   \- PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있음

   \- 클라우드는 대부분 클라우드 공급자가 정의한 구현이나 세부사항을 따라야 하는데, 

   이러한 API를 사용하면 애플리케이션을 클라우드 환경에 맞게 구성해야 하고 애플리케이션을 여러 환경에서 실행하는게 어려워짐?

   클라우드 개발자는 특정 클라우드 인프라 API로 구현되는 고수준 API를 사용하므로 <u>높은 수준의 이식 가능성을 제공</u>함

   쿠버네티스 PersistentVolume과 PersistentVolumeClaim을 사용해 특정 스토리지 구현과 관계없이 <u>애플리케이션을 추상화</u>할 수 있음(<u>역할 분리</u>)

   (물론 이식 가능성을 가지려면 클라우드 공급자(AWS, google 등)가 직접 제공하는 서비스를 사용하지 않아야 함)

<br/>


4. 효율성

   서버 운영 시 유휴 CPU 시간은 낭비 비용이기 때문에 시스템 관리자는 허용 가능한 수준으로 사용률을 유지해야 함

   쿠버네티스는 <u>기존 도구보다 고수준의 사용률 보장</u>하며 자동으로 애플리케이션을 클러스터 내 머신을 배분하는 도구를 제공함

   -> 애플리케이션 배포, 관리할 때 bash, apt 업데이트 등 많은 프로세스는 다소 비효율적임. <u>쿠버네티스</u>는 기본 솔루션에 대해 <u>선택적</u>이며 <u>추가나 제거가 용이</u>함

   

   컨테이너 세트는 네임스페이스라는 기능을 사용해 공유 쿠버네티스 클러스터에서 동작함

   과거에 개발자용 테스트 클러스터의 동작을 위해 3대의 머신을 가동해야 했지만,

   쿠버네티스의 사용으로 모든 개발자가 단일 테스트 클러스터를 쉽게 공유하고, 

   훨씬 적은 수의 머신으로 사용량을 통합하면 각 컨테이너별 전체 비용을 훨씬 낮아지므로 각 시스템의 효율성은 증가함

<br/>

## 느낀 점

지금까지 'Kubernetes up & running'이라는 책에서 말하는 쿠버네티스를 사용하는 이유에 대해 살펴봤는데, 일단 쿠버네티스 입문용으로는 아쉬움. 

쿠버네티스는 개념마다 이해해야 하는 내용이 방대한데 이걸 너무 축약하다보니 문맥상 대충 이래서 필요하구나 까지는 알겠지만 핵심적인 개념을 이해하기엔 내용이 부족하다는 걸 느꼈음.

파드, 컨테이너, 네임스페이스, 클러스터, 디플로이먼트, 서비스, ... 이런 것들이 정확히 뭘 의미하는지, 왜 만들어졌고, 어떻게 관리하는 건지 다른 책이나 쿠버네티스 공식 사이트를 참고해서 하나씩 배우면서 알아가야겠다.
