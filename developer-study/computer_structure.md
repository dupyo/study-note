# 컴퓨터 구조

## 컴퓨터 구조의 개요

1. ### **컴퓨터의 구성 요소**

   하드웨어

   - 중앙 처리 장치
   - 기억 장치
   - 입출력 장치(기계적 장치)

   소프트웨어

   - 시스템 소프트웨어

   - 응용 소프트웨어(하드웨어의 동작 제어 및 지시, 모든 종류의 프로그램)

     <br/>

   하드웨어

   1. 중앙 처리 장치(CPU)

      산술 논리 연산 장치(ALU): 사칙연산, 논리연산 수행

      제어장치: 작업 통제 및 관리 수행(순서 결정)

   2. 기억 장치(Memory)

      내부 기억 장치: 레지스터, 캐시 기억 장치, 주기억 장치(연산에 활용)

      외부 기억 장치: 보조 기억 장치(반영구 저장)

      **레지스터 -> 캐시 -> 주기억 장치 -> 보조 기억 장치 순으로 CPU에 가까움, + 용량이 작음, + 속도 빠름, + 가격이 높음*

      주기억 장치: 수행 프로그램과 필요한 데이터를 기억하는 장치. CPU에 접근 속도가 빠름. RAM(Random Access Memory)을 사용

      보조 기억 장치: 데이터를 반영구적 보존

      **CPU와 속도 차이로 직접적인 데이터 교환이 불가하여 주기억 장치로 옮겨진 후 처리됨*

   3. 입출력 장치

      입력 장치: 데이터를 기억장치로 보냄

      출력 장치: 내부에서 처리된 결과를 출력

      <br/>

   소프트웨어

   **생산성, 호환성, 유지보수 효율이 중요한 요구조건임. + 연구개발 대상*

   1. 시스템 소프트웨어

      운영체제, 컴파일러, 입출력 제어 프로그램 등 컴퓨터를 제어하고 운영하는 프로그램

   2. 응용 소프트웨어

      시스템 소프트웨어 기반으로 동작하는 프로그램

      <br/>

2. ### **컴퓨터의 분류**

   1. <u>사용 목적</u>에 따른 분류

      - 전용 컴퓨터(군사용, 공정제어)
      - 범용 컴퓨터*

   2. <u>사용 데이터</u>에 따른 분류

      - 디지털 컴퓨터(2진수)
      - 아날로그 컴퓨터
      - 하이브리드 컴퓨터

   3. 처리 능력에 따른 분류

      <u>중앙처리장치</u>와 <u>기억장치</u>의 규모에 따른 분류

      - 마이크로컴퓨터(가정용)
      - 미니컴퓨터(중소기업, 학교)
      - 메인프레임컴퓨터(다중입출력채널. 공공단체, 대기업, 병원)
      - 슈퍼컴퓨터(원자력 개발, 항공우주, 기상)

   4. <u>구조</u>에 따른 분류

      - 파이프라인 슈퍼 컴퓨터(고속 백터 계산)
      - 대규모 병렬 컴퓨터

<br/>

## 데이터의 표현과 연산

1. ### **컴퓨터 정보의 표현**

   1. 컴퓨터에서 정보의 표현

      컴퓨터는 2진법 사용(n은 비트의 수)

      (비트 -> 바이트(8비트) -> 워드 -> 킬로 -> 메가 -> ...)

   2. 수의 진법

      1. 10진법(Decimal Notation)

         0~9로 숫자 표현. 각 자리의 단위는 10의 n제곱

      2. 2진법(Binary Notation)

         0, 1만으로 숫자 표현. 각 자리의 단위는 2의 n제곱

      3. 8진법(Octal Notation)

         0~7로 숫자 표현. 각 자리의 단위는 8의 n제곱

      4. 16진법(Hexadecimal Notation)

         0\~9와 A\~F로 숫자 표현. 각 자리의 단위는 16의 n제곱
   
   3. 진법 변환
   
      각 진법에서 진수를 진법의 지수 승으로 표현하면
   
      ```latex
      M(가수) * B(기수) ^ E(지수)
      ```
   
      n진법에서 10진법으로 변환하는 경우에 효율적임
   
      소인수분해: 10진법에서 n진법으로 변환하는 경우에 효율적임
   
      <br/>
   
2. ### **데이터의 2진수 표현**

   2진수는 부호(+, -) 및 소수점을 이용하여 수를 표현

   1. 1의 보수 표현: 모든 비트들을 반전

   2. 2의 보수 표현: (부호 비트 추가 후) 1의 보수 결과값에 1을 더함

      최상위 비트: 부호, 나머지 비트: 수의 크기

      2의 보수는 0에 대한 표현이 하나만 존재함(+0만 가능. -0를 표현하려면 n비트를 벗어나기 때문). 산술 연산이 용이함

      2의 보수는 계산이 편리하고 표현 범위도 넓기 때문에 디지털 장치에 부호를 갖는 2진수를 표현하는데 사용됨

      n비트 데이터의 경우 수의 범위

      ```latex
      -2^{n-1} <= N <= 2^{n-1}-1
      ```

      *부호가 있는 2진수는 2의 보수를 사용하여 표현한다.
      
      *2의 보수로 표현된 양의 정수에서는 부호 비트(+)를 제외한 나머지 비트들이 실제 크기를 나타냄*
      
      *2의 보수로 표현된 음의 정수를 10진수로 표현하는 방법*
      
      1. 부호 비트인 최상위 비트의 자릿수를 2의 승수로 표현하고 (-)를 붙여서 음수가 되도록 하고 나머지 비트는 양의 정수와 동일하게 계산
      2. 2의 보수를 이용하여 음의 정수를 양의 정수로 변환 후 (-)부호를 붙임(계산이 용이)
      
      <br/>

3. ### **문자 데이터 표현과 2진 연산**

   영숫자 코드 - 표준 BCD(Binary Coded Decimal) 코드가 대표적임

   ​	6비트의 표준 BCD 코드의 구성으로, 64가지의 문자, 숫자, 특수문자 정보를 표현

   - 패리티 비트: 최상위 비트이며 오류 검출을 위한 비트(1의 개수를 짝수 또는 홀수로 맞추기 위해 0 또는 1을 입력)
   - 존 비트: 상위 2\~3번째 비트이며 알파벳이나 특수문자를 분류할 수 있음. 알파벳과 특수문자는 01, 10, 11로 표현하고 숫자는 00으로 표현함
   - 숫자 비트: 존 비트와 함께 정보를 표현

   ASCII 코드 - 정보 교환용 미국 표준 코드

   ​	7비트와 패리티 비트가 추가된 두 종류의 8비트 코드가 있으며, 128가지의 정보를 표현

   ​	처음 32개는 인쇄와 전송 제어용으로 사용

   ​	기억장치는 8비트(1byte, 256조합)을 기본으로 구성

   ​	8비트의 코드로 특정문자까지 표현할 수 있도록 만든 것을 확장 ASCII 코드라고 함

   ​	*2~4번째 비트까지 3개의 비트를 존 비트로 사용

   유니코드(unicode)

   ​	ASCII코드는 1바이트 이상 코드로 표현되는 비유럽 국가의 언어 표현에 한계

   유니코드의 특징

   1. 문자마다 고유한 코드 값을 제공
   2. 26개 언어의 문자와 특수기호에 코드 값을 부여
   3. 2바이트(16비트) 길이를 사용(최대 수용 문자 수: 65,536자)

   2진수 연산으로는 산술연산과 논리연산이 있으며, 부호를 갖는 산술연산은 2의 보수를 활용함

   부동소수점의 수에 대한 산술연산은 지수부분과 가수부분을 분리하여 독립적으로 수행함

   2진수 정수의 뺄셈 연산

   2의 보수를 이용하여 부호를 바꾼 후 결과적으로 덧셈을 수행함

   ```latex
   A - (+B) = A + (-B)
   A - (-A) = A + (+B)
   ```

   <br/>

   2진수의 논리 연산

   - AND 연산
   - OR 연산
   - Exclusive-OR(XOR) 연산
   - NOT(NAND, NOR, NXOR) 연산

<br/>

## 컴퓨터에서 활용되는 디지털 논리회로

1. ### **논리 게이트와 플립플롭**

   **논리 게이트**

   - AND 게이트(논리곱 연산)

     AND 게이트 진리표(기호: 반달 모양)

     | 입력(A) | 입력(B) | 출력(X) |
     | :-----: | :-----: | :-----: |
     |    0    |    0    |    0    |
     |    0    |    1    |    0    |
     |    1    |    0    |    0    |
     |    1    |    1    |    1    |

   - OR 게이트(논리합 연산)

     OR 게이트 진리표(기호: 초승달 모양)

     | 입력(A) | 입력(B) | 출력(X) |
     | :-----: | :-----: | :-----: |
     |    0    |    0    |    0    |
     |    0    |    1    |    1    |
     |    1    |    0    |    1    |
     |    1    |    1    |    1    |

   - NOT 게이트(논리 부정)

     NOT 게이트 진리표(기호: 삼각형 + 점)

     | 입력(A) | 출력(X) |
     | ------- | ------- |
     | 0       | 1       |
     | 1       | 0       |

   - XOR 게이트(배타적 논리합 연산)

     XOR 게이트 진리표(기호: 곡선 + 초승달 모양)

     | 입력(A) | 입력(B) | 입력(X) |
     | :-----: | :-----: | :-----: |
     |    0    |    0    |    0    |
     |    0    |    1    |    1    |
     |    1    |    0    |    1    |
     |    1    |    1    |    0    |

   - NAND 게이트(기호: 반달 모양 + 점)

   - NOR 게이트(기호: 초승달 모양 + 점)

   **플립플롭**

   ​	저장장치로 사용. 주기억장치RAM이나 캐시 메모리, 레지스터를 구성하는 기본 회로

   ​	전원이 있을 때만 기억 유지, 전원이 차단되면 정보가 사라지는 휘발성 기억소자임

   - **래치(LATCH)**

     조작하여 상태를 바꾸지 않는 한 그 <u>상태를 유지(기억)</u>해 주는 장치 또는 회로

     상태를 유지할 수 있도록 NAND 또는 NOR 게이트를 이용하여 구성

     논리 회로로 구성되어 있기 때문에 동작 속도가 빨라 플립플롭으로 활용

   - **R-S 플립플롭**

     클럭 펄스가 발생하는 동안에만 동작(발생하지 않으면 유지)

     R과 S에 각각 0 또는 1을 입력하여 상태 유지, 1, 0으로 상태 관리

     ※ R과 S가 동시에 1일 경우 불능 상태

   - **D 플립플롭**

     R과 S가 동시에 1인 경우(불능 상태)를 회로적으로 차단

   - **J-K 플립플롭**

     J는 S, K는 R에 대응하여 이전 출력의 보수 상태로 바꿔 출력함으로써 불능 상태를 차단

   <br/>

2. ### **조합논리회로**

   **조합 논리 회로** : 기본적인 논리소자의 조합으로 만들어지고 기억소자는 포함하지 않음

   - **전가산기**

     두 입력, 자리 올림수를 포함하여 3개를 덧셈 연산(8종류 계산)

   - **병렬가산기**

     전가산기를 병렬 연결하면 여러 비트 덧셈 연산을 수행

   - **감산기**

     입력들의 차를 출력(빌림수 발생)

   - **반감산기**

     두 입력 간의 차가 음의 값을 갖는 경우 출력에서 상위비트(빌림수)와 함께 출력

   - **전감산기**

     반감산기에서 추가적으로 아랫자리(하위비트)에서 요구하는 빌림수를 포함한 뺄셈 가능

   - **비교기**

     두 2진수의 크기를 비교하는 회로(4개 출력에서 출력)

   - **인코딩**

     정보를 표준화, 보안, 처리속도 향상, 메모리 절약 등의 목적으로 변환하는 방식(부호화)

     2^n개의 입력신호로부터 n개의 출력신호를 만듬

   - **디코딩**

     인코딩된 정보를 원래 상태로 되돌리는 처리(복호화)

     n비트의 이진코드를 최대 2^n 가지의 정보로 바꿔줌

   - **멀티플렉서(다중화기)**

     선택 신호에 의해 여러 개의 입력 중 하나의 입력만 선택되어 전달(MISO)

     N개 입력이 있다면 선택 신호는 log2N 개 만큼이 필요함

   - **디멀티플렉서(역다중화기)**

     전달된 입력을 선택선을 통해 여러 출력선 중 하나의 출력선에서만 출력

   <br/>

3. ### **순차논리회로**

   순차논리회로 = 조합논리회로 + 기억소자(피드백)

   - 동기식(클럭 펄스에 따라 상태 변화)
   - 비동기식(클럭 펄스 영향 x. 입력 값 변하는 순서에 따라 동작)

   **레지스터**

   ​	CPU 내에서 사용되는 임시저장장치

   ​	플립플롭 여러 개를 배열하여 연결

   **이동 레지스터**

   - 데이터를 좌우로 이동시키는 레지스터
   - 직렬과 병렬의 입출력 조합이 존재
   - etc) 양방향성 이동 레지스터, 순환 레지스터

   1. 병렬처리의 특징
      - 모든 비트의 데이터를 한 번에 전송
      - 전송속도가 빠름
      - 직렬 방식에 비해 하드웨어가 복잡
   2. 직렬처리의 특징
      - 한 번에 한 비트씩 전송
      - 전송속도가 느림
      - 하드웨어 규모가 간단함

   <br/>

## 컴퓨터 시스템의 구성과 기능

1. ### **컴퓨터 구성 요소**

   \- 하드웨어는 물리적인 실체로 정보들을 처리, 전송, 저장하며 전송 통로를 제공함.

   \- 하드웨어가 특정 작업을 수행하도록 제어 신호를 제공하는 부호나 명령어들의 집합을 소프트웨어라고 부름.

   \- 펌웨어는 소프트웨어를 하드웨어화한 것으로 고정적인 작업을 빠르게 수행할 수 있게 만든 것임. 미들웨어라고도 함.

   <br/>

   **컴퓨터 하드웨어 분류**

    - 중앙처리장치(CPU): 산술논리연산장치(ALU), 내부 버스, 레지스터, 제어장치

    - 기억장치

    - 입력장치

    - 출력장치

      **레지스터의 종류 - CPU의 제어 및 상태 레지스터**

      - 프로그램 카운터*
      - 명령어 레지스터
      - 기억장치 주소 레지스터
      - 기억장치 버퍼 레지스터
      - 입/출력 주소 레지스터
      - 입/출력 버퍼 레지스터

      <br/>

      **제어장치의 구성**
      
      - 순서제어 논리장치
      - 제어장치 레지스터(주소, 버퍼, 서브루틴)
      - 명령어 해독기
      - 제어 메모리

   <br/>

2. ### **컴퓨터 구성 요소 - 소프트웨어**

   컴퓨터 명령 : 정보를 처리, 이동, 저장하는 동작을 수행

   소프트웨어 : 명령들이 모인 프로그램의 집합체

   <br/>

   **소프트웨어의 분류**

   - 시스템 소프트웨어: 운영체제, 장치 드라이버, 프로그래밍 도구, 컴파일러, 어셈블러, 유틸리티, 펌웨어(효율을 위해 ROM에 저장) 등
   - 응용 소프트웨어: 특정 목적의 작업 수행(문서 작성, 연결, 기업 소프트웨어)
   
   <br/>
   
3. ### **버스와 상호연결 그리고 컴퓨터의 기능과 동작**

   하드웨어는 버스로 연결되고 버스를 통해 데이터와 각 제어 신호가 전달됨

   **버스**: 장치들을 연결하는 공유 전송 매체

   **버스 전송 유형**

   - read
   - write
   - 입출력 모듈을 통한 읽기, 전송
   - 입출력 모듈이 DMA를 통해 기억장치와 직접 데이터 교환

   <br/>

   **시스템 버스**: 프로세서, 기억장치 및 입출력 장치간의 통신을 위한 상호 연결

   - 주소 버스: 기억장소 주소 전송 
   - 데이터 버스: 모듈간 데이터 전송
   - 제어 버스: 제어신호 전송(읽기/쓰기, 버스 요구/승인, 전송 확인 등)

   <br/>

   **시스템 버스의 방향성**

   - 데이터 버스: 읽기/쓰기 동작을 모두 수행(양방향성)
   - 제어 버스: 데이터 요구 제어 신호와 전송 확인 제어 신호를 사용(양방향성)
   - 주소 버스: 주소 신호가 CPU에서 기억 장치로 전송됨(단방향성)

   <br/>

   **CPU와 기억장치의 전송**

   \- 기억 장치 쓰기 시간: CPU가 주소와 데이터를 보낸 순간부터 저장이 완료될 때까지 걸리는 시간

   \- 기억 장치 읽기 시간: 주소를 해독하는 데 걸리는 시간과 선택된 기억 소자로부터 데이터를 읽는 데 걸리는 시간을 합한 시간

   <br/>

   **CPU와 주변 장치의 전송**

   \- CPU와 입출력 장치는 처리 속도 차이가 커서 중간을 연결하는 입출력 장치 제어기(입출력 모듈)이 존재함

   <br/>

   **컴퓨터의 특징**

   - 신속성
   - 신뢰성
   - 정확성
   - 대용량성
   - 공유성

   <br/>

   **컴퓨터의 기능**

   \- 입력, 기억, 처리, 출력, 통신

   <br/>

   **컴퓨터 시스템의 동작 과정**

   **펌웨어**(ROM)에서 **부팅** -> **운영체제**(RAM)에서 **동작 제어** -> **응용 소프트웨어**로 **작업 수행**(하드디스크)

   <br/>

   **컴퓨터에서 프로그램 실행 시, 수행하는 동작**

   - 실행 : CPU가 주기억장치로부터 프로그램 코드를 읽어서 실행
   - 데이터 저장 : 프로그램 실행 결과 데이터를 주기억장치에 저장
   - 데이터 이동 : 보조기억장치에 있는 프로그램과 데이터 블록을 주기억장치로 이동
   - 데이터 입력 : 사용자가 키보드를 통해 보내는 명령이나 데이터를 읽음
   - 데이터 출력 : CPU가 처리한 결과 값이나 기억장치의 내용을 출력
   - 제어 : 프로그램의 실행 순서를 변경하도록 조정하며, 각 제어 신호를 발생

   <br/>

   **프로그램 내의 명령어가 수행되는 과정**

   명령어 인출 -> 명령어 해독 -> 명령어 실행 -> 프로그램 카운터 증가 (반복)

   <br/>

   **명령어 사이클**

   - CPU가 명령어를 실행하는 데 필요한 처리 과정

   - 인출 사이클과 실행 사이클로 구성

   - 인출 사이클은 CPU가 주기억장치로부터 명령어를 읽음

   - 실행 사이클은 명령어를 실행하는 단계로, 

     CPU와 주변장치 간에 데이터를 전송하거나 산술 또는 논리 연상을 수행

   <br/>

## 중앙처리장치의 조직과 기능

1. ### CPU와 마이크로프로세서 그리고 조직

   마이크로프로세서 : 논리 회로로 설계된 CPU를 집적회로 칩으로 만든 것

   머신 사이클 : 명령어가 실행되기까지의 4단계 과정(인출->해독->실행->저장)

   <br/>

   **클럭 주파수**

   - CPU가 일정 속도로 동작하기 위해 공급되는 전기적 진동(pulse)
   - 1초 동안 발생한 클럭 수
   - 메인보드에 장착되어 있는 클럭 발생기에서 클럭 생성
   - 클럭 수가 높을수록 처리 속도가 빠름

   <br/>

   **명령어 처리 속도**

   - 초당 처리하는 명령어의 개수(단위 : MIPS)

   - 클럭 주파수는 명령어마다 다르기 때문에 정확한 처리 속도를 판단하기 어려움. 

     컴퓨터의 정확한 처리 속도를 판단하기 위해서 처리하는 명령어의 개수를 기준으로 함

   <br/>

   **연산장치 - 산술논리연산장치(ALU)**

   \- ALU의 구성

   - 산술 및 부울 논리 연산기 : 산술 연산, 논리 연산 수행하는 회로
   - 상태 플래그 : 연산 중인 데이터 상태 표시. 예) 음수, 0, 오버플로우 표시
   - 이동기 : 좌우 비트 이동. 2로 곱셈 나눗셈
   - 보수기 : 주로 2의 보수 연산 수행. 덧셈 뺄셈 용이

   <br/>

   **프로세서 레지스터 - 레지스터**

   \- 컴퓨터 기억장치 중 속도가 가장 빠름

   \- 연산 결과 데이터를 임시적으로 보관. 

   \- 주기억장치로부터 읽어온 명령어와 데이터를 임시 보관

   \- 레지스터의 용도별 분류

   - 데이터 레지스터 : 정수 데이터 값 저장
   - 주소 레지스터 : 기억장치 주소 저장하여 접근할 때 사용
   - 범용 레지스터 : 데이터 + 주소 저장
   - 부동 소수점 레지스터 : 부동소수점 데이터 값 저장
   - 상수 레지스터 : 0이나 1 등 고정 데이터 값 저장
   - 특수 레지스터 : 실행 중인 프로그램 상태 저장(프로그램 카운터, 상태 레지스터)
   - 명령 레지스터 : 실행 중인 명령어 저장
   - 색인 레지스터 : 피연산자 주소 계산

   <br/>

   **사용자에게 보이는 CPU 레지스터**

   \- 어셈블리 프로그래머는 프로그램에서 사용되는 변수 데이터 저장을 위해 해당 레지스터를 알고 있어야 함

   \- 사용 목적에 따른 분류

   - 일반목적용 레지스터 
   - 데이터 레지스터 : 데이터 저장에만 사용(누산기)
   - 주소 레지스터 : 특정 주소 지정 방식에 사용 - 스택 포인터(TOP의 주소 저장)
   - 조건 코드 : 저장된 데이터의 상태 표시 - 부호 비트, 영(0) 비트, 오버플로우 비트 

   <br/>

   **스택(Stack) 저장장치**

   \- 스택의 특징

   - CPU 내 레지스터 집합에 존재
   - 스택 길이는 가변적
   - 한 번에 하나의 요소에만 액세스
   - LIFO

   \- 스택의 동작

   - TOP, PUSH, POP, 스택 포인터(TOP의 위치 표시)

   <br/>

2. ### CPU의 조직과 CPU 논리회로

   **제어장치**

   \- 명령어 해독. 제어 신호를 내부 버스를 통해 전달

   \- 명령어 형식

   | 연산 코드(연산자) | 기억장치 주소(피연산자) |
   | :---------------: | :---------------------: |

   \- 제어장치 구성요소

   - 기억장치 버퍼 레지스터 : 주기억장치로부터 읽어온 명령어 임시 저장
   - 명령어 레지스터 : 명령어 저장
   - 명령어 해독기 : 명령어 해독하여 연산 결정
   - 기억장치 주소 레지스터 : 명령어 레지스터에 저장된 명령어 주소 저장
   - 프로그램 카운터 : 다음 수행할 명령어 주소 저장

   <img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20211227161810418.png" alt="제어장치의 구성" style="zoom:50%;" />

   **내부 CPU 버스**

   \- 이동경로 제공

   - ALU <-> 레지스터
   - ALU <-> 제어장치
   - 제어장치 <-> 레지스터

   \- 기억장치 버퍼 레지스터와 기억장치 주소 레지스터는 CPU 내부와 외부 장치 간 속도 차를 극복하기 위한 버퍼 역할임

   <br/>

   **연산장치**

   \- *산술연산장치는 연산될 데이터와 연산 결과를 기억시킬 레지스터(누산기)와 연산의 상태를 나타내는 상태 레지스터들의 연결이 필요함 

   \- 논리 게이트를 이용하여 조합논리 회로를 구성하면 다양한 논리연산 수행 - 연산 지시 신호

   \- 연산 지시 신호 : 논리연산 선택, 결과 기억 장소 지움선, NOT 연산 보수 회선 존재

   \- 산술연산 회로 + 논리연산 회로 = ALU(+자리올림수, 선택신호)

   <br/>

   **이동기**

   \- 양방향 이동 레지스터. 발전형 -> 카운터

   <br/>

   **제어장치의 유형**

   - 하드와이어적 제어장치 : 제어 신호 생성 빠름. 회로도 매우 복잡
   - 마이크로 프로그램 제어장치 : 펌웨어. 설계 간결. 하드웨어 최소화 저렴. 자기 진단 기능 구비

   <br/>

3. ### CPU의 기능과 동작 그리고 성능

   **CPU의 공통 수행 기능**

   - 명령어 인출
   - 명령어 해독

   <br/>

   **추가되는 명령어의 기능**

   - 주기억장치(RAM) 또는 입출력장치로부터 데이터 인출
   - 데이터에 대해 산술 또는 논리 연산 수행
   - 데이터 처리 결과 저장

   <br/>

   **CPU의 4단계 기본 동작 and 제어장치**

   - 주기억장치(RAM)에서 데이터 인출되어 버스를 통해 레지스터로 전달
   - 제어장치는 기존에 저장하고 있던 데이터와 연산하라는 제어신호를 ALU에 전달
   - ALU에서 제어신호를 받아 연산 수행하고 그 결과를 누산기에 저장
   - 연산 결과는 외부 시스템 버스를 통해 다시 주기억장치로 전달

   <br/>

   **프로그램 카운터 역할**

   - 항상 앞에서부터 한 명령씩 차례대로 실행
   - 조건부 분기(JUMP)의 경우, 증가 회로에서 분기가 일어나 프로그램 카운터의 내용(주소)를 바꿔 분기된 이후부터의 명령어 실행

   <br/>

   **제어장치의 동작을 포함한 CPU의 동작**

   - 주기억장치에서 명령어를 제어장치 내 기억장치 버퍼 레지스터로 전달
   - 기억장치 버퍼 레지스터에서 명령어를 명령어 레지스터로 보냄
   - 명령어 레지스터에서 연산 코드는 명령어 해독기로, 피연산자 주소는 기억장치 주소 레지스터로 보냄
   - 명령어 해독기에서 명령어를 해독한 뒤 연산을 결정하여 제어 신호를 연산장치로 보냄
   - 프로그램 카운터에 다음 실행할 명령어 주소를 저장
   - 기억장치 주소 레지스터에 저장되어 있는 피연산자 주소로 주기억장치 내 해당 주소에 접근하여 데이터를 인출해서 연산장치로 전달
   - 연산장치에서 연산을 수행하고 연산에 사용된 데이터와 연산 결과를 누산기에 저장
   - 최종적으로 연산 결과를 주기억장치로 보내어 저장

   <br/>

   **CPU가 데이터를 처리하는 속도를 판단하는 요소**

   - 클럭 주파수 - 클럭 주기가 짧을수록 클럭 주파수가 높음. 

     특정 시간동안 완수할 수 있는 명령어의 수가 더 정확함

   - 워드 크기 - CPU가 한번에 읽고 쓸 수 있는 비트 수. 레지스터의 크기와 버스 데이터 선로 수에 따라 워드 크기 증가

   - 캐시 메모리 - 읽기 쓰기 속도 향상. CPU가 빠르게 접근 가능한 고속 기억장치

   - 명령어 집합의 복잡성(RISC) - 연산속도를 향상시키기 위한 단순화된 명령어 구조

   - 파이프라이닝 - CPU 또는 프로세서가 이전 명령어 수행 종료 전에 다음 명령어 수행 시작. CPU 처리 속도 증가

   - 병렬처리 - 하나 이상의 CPU로 구성된 컴퓨터에서 한번에 여러 개의 명령어를 동시에 수행. 처리 속도 증가

   <br/>

## 주기억장치

1. ### 기억장치의 개요

   기억장치

   - 주기억장치 - CPU와 직접적인 통신
   - 보조기억장치 - 데이터 영구 저장

   기억장치의 성능 평가 요소

   - 기억용량(바이트 등), 접근 시간(읽기+쓰기), 사이클 시간(접근 시간 - 반도체 또는 자기 코어)
   - 기억장치의 대역폭(전송 또는 저장 비트 수), 데이터 전송률(초당 비트 수), 가격(처리속도)

   기억장치의 계층적 구조

   \- CPU 내 레지스터 > 캐시기억장치 > 주기억장치 > 보조기억장치 순으로 용량은 낮고 속도와 가격은 높음

   기억장치의 분류

   1. 제조 재료에 따른 유형
      - 반도체 기억장치
      - 자기-표면 기억장치
   2. 저장 성질에 따른 유형
      - 휘발성 기억장치 - RAM
      - 비휘발성 기억장치 - ROM, CD-ROM
   3. 접근 방법에 따른 유형
      - 순차적 접근 - 테이프
      - 직접 접근 - 하드디스크
      - 임의 접근 - RAM, ROM
