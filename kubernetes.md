## 쿠버네티스를 사용하는 이유

1. 속도

   - 높은 가용성으로 서비스를 유지하며 제공할 수 있는 항목의 수

   - 가용성을 확보할 수 있게 하는 핵심 개념 
   1) 불변성
     기존에 사용하던 인프라는 변경 가능했음(증분 업데이트)
     기존 컨테이너 이미지를 수정하는 것이 아니라 새로운 컨테이너 이미지를 만들고 컨테이너 레지스트리에 주입
     아티팩트 생성과 생성 시 방법에 대한 기록 -> 새로운 버전에 오류가 있는 경우 오류를 명확하게 확인 가능
   2) 선언형 설정
     선언형 설정 <-> 명령형 설정
     명령형 설정 : 명령문 위주의 동작을 정의(예: A 실행, B 실행, C 실행)
     선언형 설정 : 요구하는 상태를 정의(실제 상태를 기술. 설정의 영향을 실행 이전에 해석하므로 오류 발생 가능성이 적음)
     변경에 대한 롤백을 쉽게 만들 수 있음 <-> 되돌아오는 방법을 기술하지 않으므로 사실상 롤백 불가
     소스 제어, 코드 리뷰, 유닛 테스트를 선언형 설정에 사용 가능
   3) 자가 치유 시스템
     요구하는 상태 설정을 받으면 현재 상태를 요구하는 상태로 일치시키려고 
     끊임없이 확인하고 요구된 상태로 유지함


2. 확장성

   - 분리
   분리된 아키텍처를 지향해 확장성 확보
   API와 로드밸런서는 시스템 각 부분들(컴포넌트)를 격리, 분리하는 역할을 함
   분리된 아키텍처에서 컴포넌트를 분리하면 프로그램 크기와 처리 용량을 증가시켜도 재설정이 필요 없음
   API를 통해 서버를 분리하면 개발에 집중할 수 있음


   - 쉬운 애플리케이션 및 클러스터 확장
   불변적인 선언적 속성으로 서비스를 쉽게 확장 또는 자동 확장 설정 가능
   클러스터 확장
   클러스터 내부 머신들은 서로 완전히 동일하고 컨테이너는 애플리케이션을 머신 세부사항과 분리하므로 
   새로운 자원을 클러스터에 추가하는 작업은 새로운 머신을 이미징하고 클러스터에 추가하기만 하면 됨

   * 프로비저닝(provisioning): 사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요 시 
     시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것
   * 애플리케이션 컨테이너 이미지와 머신을 분리하면 동일한 머신에서 각 마이크로서비스를 
     서로 간섭하지 않도록 배치할 수 있고 마이크로서비스 아키텍처에서 오버헤드와 비용을 줄일 수 있음?
   * 쿠버네티스의 상태 진단과 롤아웃 기능은 애플리케이션 롤아웃과 안정성에 일관된 접근을 보장함?
     -> 개발 팀이 서비스 제품 생명주기와 운영에 영향을 미치지 않음
   * 컨테이너 애플리케이션의 운영자의 책임과 클러스터 오케스트레이션 운영자 책임 분리
     -> 컨테이너 오케스트레이션 API의 안정성을 담당하는 엔지니어는 API를 이용해 동작하는 
     애플리케이션에 대해 고민할 필요 없이 오케스트레이션 SLA를 제공하는 일에만 전념하면 됨?



3. 인프라 추상화


4. 효율성